프로그래밍 언어를 설계할 때 언어 설계자는 사용자가 메모리를 관리할 방법을 정해야 한다.

CPython에서는 1.참조카운팅, 2.가비지 컬렉션 두 가지 관점에서 메모리를 관리한다.

C는 크게 세가지 메모리 관리 방식을 사용한다.
1. 정적 메모리 할당: 필요한 메모리는 컴파일 시간에 계산되고 실행파일이 실행될 때 할당된다.
2. 자동 메모리 할당: 스코프에 필요한 메모리는 프레임에 진입할 때 콜스택 내에 할당되고 프레임이 끝나면 해제된다.
3. 동적 메모리 할당: 메모리 할당 API를 호출해 메모리를 동적으로 요청하고 할당한다. 운영체제는 메모리를 동적으로 할당할 수 있도록 시스템 메모리의 일부를 예약해두는데 이를 힙이라고 한다.

C기반의 CPython은 C메모리 할당 방식의 제약조건을 따르며 Python 언어 설계를 준수해야한다. 하지만 변수의 크기를 컴파일시간에 계산할 수 없는 동적언어, 코어 타입의 크기가 동적이라는 특징, 덕타이핑 등의 이유로 동적메모리 할당에 크게 의존하는 형태를 가진다. 메모리 해제 시에는 가비지 컬럭션과 참조 카운팅 알고리즘을 통해 안전장치를 추가했다.
파이썬 객체 메모리는 개발자가 할당하는 대신 하나의 통합 API를 통해 자동으로 할당된다.

CPython의 메모리 할당 알고리즘
- 
대부분의 메모리 할당요청은 고정된 크기의 작은 메모리를 요구한다.
메모리 블록은 고정된 크기로 구성된다.
같은 크기의 블록들로 풀이 이루어진다.
중앙 레지스터가 블록위치와 사용가능한 블록의 개수를 관리한다. 한 풀이 꽏차면 다음 풀이 사용된다. 풀 들은 다시 아레나라는 단위로 묶인다.

1. 이 알고리즘은 CPython에서 주로 만들어지는 작고 수명이 짧은 객체에 적합하다.
2. 시스템 스레드 잠금 검사 기능 대신에 GIL을 사용한다.
3. 힙 할당 대신에 메모리 맵을 사용한다.

풀: 풀은 "포화", "사용 중", "미사용" 세 가지 상태를 가진다. 아레나의 최고 수위선은 마지막으로 할당된 풀에 표시된다. 풀은 같은 단위의 이전 풀과 다음풀에 연결되어 같은 단위의 풀을 쉽게 탐색할 수 있다.

파이썬의 변수 생성
- 
파이썬에서 변수에 값을 할당할 때는 변수 이름이 지역 또는 전역 스코프에 이미 존재하는지 확인한다.

어딘가 값에 의존한다면 참조 카운트는 증가하고, 의존하지 않게 되면 감소한다. 참조카운트가 0이 되면 메모리는 해제된다.

CPython 참조 카운터는 단순함과 속도, 효율성을 제공한다. 하지만 그 대신 모든 연산의 효과를 고려해 신중하게 균형을 맞춰주어야 한다는 단점 역시 가지고 있다. 또 순환참조라는 중대한 결함을 가지고 있기도 하다. 이를 해결하기 위해 가비지 컬렉터가 필요하다.

가비지 컬렉션
- 
가비지 컬렉션은 기본적으로 활성화 되어있고, 백그라운드에서 실행한다.
단, 참조 카운팅보다 알고리즘이 복잡하기 때문에, 일정 양 이상의 연산이 일어났을때에만 주기적으로 실행된다.

CPython은 locals(), globals()만으로는 모든 객체를 확인할 수 없다. 따라서 mark and swap, stop and copy등의 일부 알고리즘은 사용할 수 없다.

CPython 가비지 컬렉터의 역할은 참조카운터를 활용하여 특정한 가변 컨테이너 타입의 순환참조를 찾는 것이다.

수거가 시작되면 컬렉터는 어린 세대를 현재 세대와 병합한다.
해당 세대의 모든 객체에 대해 참조카운트 값을 복사한다.
모든 객체의 참조카운트에서 순환참조를 제거해 얼마나 많은 객체를 수거할 지 결정한다.
참조카운트가 0인 객체리스트를 만들고 값을 추가한다.
리스트의 대상을 모두 제거한다.

세대별 가비지 컬렉션은 대부분(80+%)의 객체가 생성직후 파괴된다는 관측에서 근거한 기법이다. 젊은 세대일수록 높은 임계값을 가진다.